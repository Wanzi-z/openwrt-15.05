--- a/mt7915/mac.c
+++ b/mt7915/mac.c
@@ -568,6 +568,8 @@
 {
 
 	u8 tid = skb->priority & IEEE80211_QOS_CTL_TID_MASK;
+	struct ethhdr *ehdr = (struct ethhdr *)skb->data;
+	bool multicast = is_multicast_ether_addr(ehdr->h_dest);
 	u8 fc_type, fc_stype;
 	bool wmm = false;
 	u32 val;
@@ -577,12 +579,15 @@
 
 		sta = container_of((void *)wcid, struct ieee80211_sta, drv_priv);
 		wmm = sta->wme;
+
+		if (test_bit(MT_WCID_FLAG_4ADDR, &wcid->flags))
+			multicast = false;
 	}
 
 	val = FIELD_PREP(MT_TXD1_HDR_FORMAT, MT_HDR_FORMAT_802_3) |
 	      FIELD_PREP(MT_TXD1_TID, tid);
 
-	if (be16_to_cpu(skb->protocol) >= ETH_P_802_3_MIN)
+	if (be16_to_cpu(ehdr->h_proto) >= ETH_P_802_3_MIN)
 		val |= MT_TXD1_ETH_802_3;
 
 	txwi[1] |= cpu_to_le32(val);
@@ -591,7 +596,11 @@
 	fc_stype = wmm ? IEEE80211_STYPE_QOS_DATA >> 4 : 0;
 
 	val = FIELD_PREP(MT_TXD2_FRAME_TYPE, fc_type) |
-	      FIELD_PREP(MT_TXD2_SUB_TYPE, fc_stype);
+	      FIELD_PREP(MT_TXD2_SUB_TYPE, fc_stype) |
+	      FIELD_PREP(MT_TXD2_MULTICAST, multicast);
+
+	if (multicast)
+		val |= MT_TXD2_FIX_RATE;
 
 	txwi[2] |= cpu_to_le32(val);
 
@@ -858,19 +887,17 @@
 		ieee80211_start_tx_ba_session(sta, tid, 0);
 }
 
-static void
-mt7915_tx_complete_status(struct mt76_dev *mdev, struct sk_buff *skb,
-			  struct ieee80211_sta *sta, u8 stat,
-			  struct list_head *free_list)
+static inline void
+mt7915_tx_status(struct ieee80211_sta *sta, struct ieee80211_hw *hw,
+		 struct ieee80211_tx_info *info, struct sk_buff *skb)
 {
-	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
 	struct ieee80211_tx_status status = {
 		.sta = sta,
 		.info = info,
-		.skb = skb,
-		.free_list = free_list,
 	};
-	struct ieee80211_hw *hw;
+
+	if (skb)
+		status.skb = skb;
 
 	if (sta) {
 		struct mt7915_sta *msta;
@@ -879,6 +886,17 @@
 		status.rate = &msta->stats.tx_rate;
 	}
 
+	/* use status_ext to report HE rate */
+	ieee80211_tx_status_ext(hw, &status);
+}
+
+static void
+mt7915_tx_complete_status(struct mt76_dev *mdev, struct sk_buff *skb,
+			  struct ieee80211_sta *sta, u8 stat)
+{
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+	struct ieee80211_hw *hw;
+
 	hw = mt76_tx_status_get_hw(mdev, skb);
 
 	if (info->flags & IEEE80211_TX_CTL_AMPDU)
@@ -891,7 +909,17 @@
 		info->flags |= IEEE80211_TX_STAT_ACK;
 
 	info->status.tx_time = 0;
-	ieee80211_tx_status_ext(hw, &status);
+
+	if (info->flags & (IEEE80211_TX_CTL_REQ_TX_STATUS |
+			   IEEE80211_TX_CTL_HW_80211_ENCAP)) {
+		mt7915_tx_status(sta, hw, info, skb);
+		return;
+	}
+
+	if (sta || !(info->flags & IEEE80211_TX_CTL_NO_ACK))
+		mt7915_tx_status(sta, hw, info, NULL);
+
+	ieee80211_free_txskb(hw, skb);
 }
 
 void mt7915_txp_skb_unmap(struct mt76_dev *dev,
@@ -912,8 +940,6 @@
 	struct mt76_dev *mdev = &dev->mt76;
 	struct mt76_txwi_cache *txwi;
 	struct ieee80211_sta *sta = NULL;
-	LIST_HEAD(free_list);
-	struct sk_buff *tmp;
 	u8 i, count;
 
 	/* clean DMA queues and unmap buffers first */
@@ -984,22 +1010,16 @@
 					atomic_cmpxchg(&wcid->non_aql_packets, pending, 0);
 			}
 
-			mt7915_tx_complete_status(mdev, txwi->skb, sta, stat, &free_list);
+			mt7915_tx_complete_status(mdev, txwi->skb, sta, stat);
 			txwi->skb = NULL;
 		}
 
 		mt76_put_txwi(mdev, txwi);
 	}
+	dev_kfree_skb(skb);
 
 	mt7915_mac_sta_poll(dev);
 	mt76_worker_schedule(&dev->mt76.tx_worker);
-
-	napi_consume_skb(skb, 1);
-
-	list_for_each_entry_safe(skb, tmp, &free_list, list) {
-		skb_list_del_init(skb);
-		napi_consume_skb(skb, 1);
-	}
 }
 
 void mt7915_tx_complete_skb(struct mt76_dev *mdev, struct mt76_queue_entry *e)
@@ -1032,8 +1052,7 @@
 
 		wcid = rcu_dereference(dev->mt76.wcid[cb->wcid]);
 
-		mt7915_tx_complete_status(mdev, e->skb, wcid_to_sta(wcid), 0,
-					  NULL);
+		mt7915_tx_complete_status(mdev, e->skb, wcid_to_sta(wcid), 0);
 	}
 }
 
